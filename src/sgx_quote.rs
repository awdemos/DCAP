use crate::{error::NegotiationError, model::RFQ, Result};
use base64::{engine::general_purpose, Engine};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use std::sync::Arc;
use tokio::sync::Mutex;

/// Mock SGX attestation quote structure
/// In production, this would be generated by real Intel SGX hardware
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SgxQuote {
    pub quote_data: Vec<u8>,
    pub report_data: Vec<u8>,
    pub signature: Vec<u8>,
    pub enclave_version: u32,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

/// Mock EGO enclave interface
/// In production, this would interface with real Edgeless EGO
#[derive(Debug, Clone)]
pub struct Enclave {
    pub id: String,
    pub version: u32,
    pub debug_mode: bool,
    pub sealed_data: Arc<Mutex<Vec<u8>>>,
}

impl Enclave {
    pub fn new(id: String, version: u32, debug_mode: bool) -> Self {
        Self {
            id,
            version,
            debug_mode,
            sealed_data: Arc::new(Mutex::new(Vec::new())),
        }
    }

    /// Generate an attested quote for RFQ data
    pub async fn generate_quote(&self, rfq: &RFQ) -> Result<SgxQuote> {
        // Hash the RFQ data
        let rfq_json = serde_json::to_vec(rfq)
            .map_err(|e| NegotiationError::Validation(format!("Failed to serialize RFQ: {}", e)))?;
        let mut hasher = Sha256::new();
        hasher.update(&rfq_json);
        let rfq_hash = hasher.finalize();

        // In real SGX, this would be generated inside the enclave
        // For now, we create a mock quote
        let quote = SgxQuote {
            quote_data: format!("SGX_QUOTE_{}_{}", self.id, self.version).into_bytes(),
            report_data: rfq_hash.to_vec(),
            signature: format!("MOCK_SIG_{}", hex::encode(&rfq_hash)).into_bytes(),
            enclave_version: self.version,
            timestamp: chrono::Utc::now(),
        };

        tracing::info!("Generated SGX quote for RFQ {}", rfq.id);
        Ok(quote)
    }

    /// Verify an SGX quote's authenticity
    pub async fn verify_quote(&self, quote: &SgxQuote, rfq: &RFQ) -> Result<bool> {
        // In production, this would verify against Intel DCAP infrastructure
        // For now, we do basic validation

        // Verify the RFQ hash matches
        let rfq_json = serde_json::to_vec(rfq)
            .map_err(|e| NegotiationError::Validation(format!("Failed to serialize RFQ: {}", e)))?;
        let mut hasher = Sha256::new();
        hasher.update(&rfq_json);
        let expected_hash = hasher.finalize();

        if quote.report_data != expected_hash.as_slice() {
            tracing::warn!("RFQ hash mismatch in SGX quote verification");
            return Ok(false);
        }

        // Verify enclave version matches
        if quote.enclave_version != self.version {
            tracing::warn!("Enclave version mismatch in SGX quote");
            return Ok(false);
        }

        // Verify quote is not expired (5 minute TTL)
        let expiry = quote.timestamp + chrono::Duration::minutes(5);
        if chrono::Utc::now() > expiry {
            tracing::warn!("SGX quote expired");
            return Ok(false);
        }

        tracing::info!("SGX quote verification successful for RFQ {}", rfq.id);
        Ok(true)
    }

    /// Seal data to the enclave
    pub async fn seal_data(&self, data: &[u8]) -> Result<Vec<u8>> {
        let mut sealed = self.sealed_data.lock().await;
        *sealed = data.to_vec();

        // In production, this would use real SGX sealing
        let sealed_data = format!("SEALED_{}_{}", self.id, hex::encode(data)).into_bytes();
        Ok(sealed_data)
    }

    /// Unseal data from the enclave
    pub async fn unseal_data(&self, sealed_data: &[u8]) -> Result<Vec<u8>> {
        // In production, this would use real SGX unsealing
        let sealed_str = String::from_utf8(sealed_data.to_vec())
            .map_err(|e| NegotiationError::Validation(format!("Invalid sealed data: {}", e)))?;

        if !sealed_str.starts_with("SEALED_") {
            return Err(NegotiationError::Validation("Invalid sealed data format".to_string()));
        }

        let parts: Vec<&str> = sealed_str.split('_').collect();
        if parts.len() != 3 || parts[1] != self.id {
            return Err(NegotiationError::Validation("Sealed data not bound to this enclave".to_string()));
        }

        let data = hex::decode(parts[2])
            .map_err(|e| NegotiationError::Validation(format!("Failed to decode sealed data: {}", e)))?;

        Ok(data)
    }
}

/// SGX Quote Manager - handles quote generation and verification
#[derive(Debug)]
pub struct SgxQuoteManager {
    enclave: Enclave,
    enabled: bool,
}

impl SgxQuoteManager {
    pub fn new(enabled: bool) -> Self {
        let enclave = Enclave::new(
            "dcap-quote-enclave".to_string(),
            1,
            true, // debug mode for development
        );

        Self { enclave, enabled }
    }

    /// Generate an attested quote for an RFQ
    pub async fn generate_attested_quote(&self, rfq: &RFQ) -> Result<Option<SgxQuote>> {
        if !self.enabled {
            tracing::debug!("SGX quotes disabled, returning None");
            return Ok(None);
        }

        let quote = self.enclave.generate_quote(rfq).await?;
        Ok(Some(quote))
    }

    /// Verify an SGX quote
    pub async fn verify_quote(&self, quote: &Option<SgxQuote>, rfq: &RFQ) -> Result<bool> {
        if !self.enabled {
            // If SGX is disabled, we accept quotes without verification
            tracing::debug!("SGX verification disabled, accepting quote");
            return Ok(true);
        }

        match quote {
            Some(sgx_quote) => self.enclave.verify_quote(sgx_quote, rfq).await,
            None => {
                tracing::warn!("Quote missing SGX attestation");
                Ok(false)
            }
        }
    }

    /// Check if SGX is enabled
    pub fn is_enabled(&self) -> bool {
        self.enabled
    }

    /// Get enclave info for debugging
    pub fn enclave_info(&self) -> &Enclave {
        &self.enclave
    }
}

/// Configuration for SGX integration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SgxConfig {
    pub enabled: bool,
    pub require_quotes: bool,
    pub debug_mode: bool,
    pub enclave_path: Option<String>,
}

impl Default for SgxConfig {
    fn default() -> Self {
        Self {
            enabled: false, // Disabled by default for development
            require_quotes: false,
            debug_mode: true,
            enclave_path: None,
        }
    }
}

impl SgxConfig {
    pub fn from_env() -> Self {
        Self {
            enabled: std::env::var("SGX_ENABLED")
                .map(|v| v.to_lowercase() == "true")
                .unwrap_or(false),
            require_quotes: std::env::var("SGX_REQUIRE_QUOTES")
                .map(|v| v.to_lowercase() == "true")
                .unwrap_or(false),
            debug_mode: std::env::var("SGX_DEBUG")
                .map(|v| v.to_lowercase() == "true")
                .unwrap_or(true),
            enclave_path: std::env::var("SGX_ENCLAVE_PATH").ok(),
        }
    }
}